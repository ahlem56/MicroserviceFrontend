import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import {Vehicle} from "./vehicle.service";

// Define the Driver interface
export interface Driver {
  userId?: number;  // Make userId optional since it's auto-generated by the backend
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  availabilityD: boolean;  // availability status
  address: string;       // Added address field
  cin: string;           // Added contact field
  profileImageUrl?: string;  // Add this line
  licenseNumberD?: string;
  insuranceDetailsD?: string;
  averageRating?: number;
  vehicule?:Vehicle;


}
@Injectable({
  providedIn: 'root'
})
export class DriverService {

  // Route through API Gateway â†’ proxy.conf.json sends /driver-service/** to driver microservice
  private baseUrl = '/driver-service/examen/driver';

  private authHeaders(): HttpHeaders {
    return new HttpHeaders({
      'Authorization': `Bearer ${localStorage.getItem('token') || ''}`,
      'Content-Type': 'application/json'
    });
  }


  constructor(private http: HttpClient) { }

  // Fetch available drivers (users with role DRIVER and availabilityD=true if present)
  getAvailableDrivers(): Observable<Driver[]> {
    return this.getAllDrivers().pipe(
      map(users => users.filter(u => (u as any).availabilityD === true || (u as any).availabilityD === 'true'))
    );
  }

  getAllDrivers(): Observable<Driver[]> {
    return this.http
      .get(`${this.baseUrl}/get-all-drivers`, {
        headers: this.authHeaders(),
        responseType: 'text' as 'json'
      })
      .pipe(
        map((raw: any) => {
          if (raw == null) {
            return [];
          }

          const toArray = (value: any): Driver[] => {
            if (!value) return [];
            if (Array.isArray(value)) return value as Driver[];
            if (Array.isArray(value?.data)) return value.data as Driver[];
            if (Array.isArray(value?.content)) return value.content as Driver[];
            return [];
          };

          if (typeof raw !== 'string') {
            return toArray(raw);
          }

          const text = raw.trim();
          if (!text) return [];
          if (text.startsWith('<')) {
            throw new Error('Unexpected HTML response from gateway when fetching drivers.');
          }

          try {
            const parsed = JSON.parse(text);
            return toArray(parsed);
          } catch {
            throw new Error('Failed to parse driver list response.');
          }
        })
      );
  }

  createDriver(driver: Driver): Observable<Driver> {
    return this.http.post<Driver>(`${this.baseUrl}/createDriver`, driver, {
      headers: this.authHeaders()
    });
  }

  deleteDriver(id: number): Observable<void> {
    return this.http.delete<void>(`${this.baseUrl}/delete/${id}`, {
      headers: this.authHeaders()
    });
  }
  // Get a driver by ID
  getDriverById(driverId: string): Observable<Driver> {
    return this.http.get<Driver>(`${this.baseUrl}/find-driver/${driverId}`, {
      headers: this.authHeaders()
    });
  }

  // Update driver details
  updateDriver(driverId: number, driver: Driver): Observable<Driver> {
    return this.http.put<Driver>(`${this.baseUrl}/update/${driverId}`, driver, {
      headers: this.authHeaders()
    });
  }

  getDriverProfile(driverId: number): Observable<Driver> {
    return this.http.get<Driver>(`${this.baseUrl}/view-driver-profile/${driverId}`, {
      headers: this.authHeaders()
    });
  }
}
